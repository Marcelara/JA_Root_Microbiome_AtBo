---
title: "8_joint_ASV_classifications"
author: "Pedro"
date: "11/10/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---


# load libraries and data
```{r}
source("./Code/Functions/load_libraries.R")
load("./R output/env.1_Loading_and_pre_processing.RData")
```


```{r}
# first, let;s make a new physeq object we can alter in this script without messing up the original object
ASV_importance_physeq_list <- ps_list_rarefied

# this is the object we actualy need:
#simplified_ASV_importance_scores
```




# 8.1 - RANDOM FOREST ################################################

based on 7.4 add the rf classification as part of the OTU taxonomy

If the ASV is classified as important by boruta on scrip 7, give score 1 on the variable "important_in_rf", or else score 0

```{r boruta}

# add the rf classification as part of the OTU taxonomy  to a list of phyloseq objects
rf_added_tax <- mapply(function(x, y) {
  tax_table(x) %>% # get tax table of the phyloseq object...
    as.data.frame() %>% # turn it into a dataframe so mutate can work
    mutate(
      important_in_rf = # make anew variable caled random_forest_relevance, where...
        if_else(taxa_names(x) %in% y == TRUE, 1, 0)
    )
}, # if the taxa names are present in the boruta list of selected ASVs, tag them as inportant
x = ASV_importance_physeq_list,
y = boruta_ASV_list,
SIMPLIFY = FALSE
)

# now this is a phyloseq object  (df turned into amatrix)
rf_added_tax <- lapply(rf_added_tax, function(x) tax_table(as.matrix(x)))

# output
rf_added_tax
```

# 8.2 - NETWORK ANALYSIS

base on script 6.8 - Export network data, utilizing the object complete_node_metrics_withFitClass

makes 3 new variables, giving value of 1 if they are classified as keystone, module hub, or module connector. If they don't have this tag, give value 0

```{r}

# all the node merics from the netowrk analysis
complete_node_metrics_withFitClass

# asing 1/0 for presence absence
# BUG: for some reason, complete_node_metrics_withFitClass$Arabidopsis_thaliana.Root$Zi has " 0" instead of "0"
# this also happens for the keystone definition on other data partitions
# this if fixed if I make it true = "1" instead of true = 1. I will use this dirty fix for now
network_tags <- lapply(complete_node_metrics_withFitClass, function(x) {
  mutate(x, is_module_hub = if_else(condition = x$Zi >= 2.5,
    true = "1",
    false = "0"
  ))
}) # make new variable is_module_hub, based on Zi values

network_tags <- lapply(network_tags, function(x) {
  mutate(x, is_module_connector = if_else(condition = x$Pi >= 0.62,
    true = 1,
    false = 0
  ))
}) # make new variable is_module_hub, based on Pi values

network_tags <- lapply(network_tags, function(x) {
  mutate(x, is_keystone_taxa = if_else(condition = x$keystone_taxa == "Keystone",
    true = "1",
    false = "0"
  ))
}) # updates keystone variable is_module_hub, based on keystone tag


# bug: for some reason, complete_node_metrics_withFitClass$Arabidopsis_thaliana.Root$Zi has " 0" instead of "0"


# remove uncessary network metrics and turn it into a phyloseq object
network_tags <- lapply(
  network_tags, function(x) { # for each emeber of this lsit....
    select(x, Row.names, is_keystone_taxa, is_module_hub, is_module_connector, DADA2_ID) %>% # select some of the variables, and then...
      column_to_rownames(var = "Row.names") %>% # turn the Row.Names vector into actual rownames, then...
      as.matrix() %>% # then force it into a matrix to fit tax_table, then..
      tax_table()
  } # make it a tax_table phyloseq object
)

# output
network_tags
```

# 8.3 - NEUTRAL MODELS ###############################################3
based on 4.5 Add neutral fit classes of OTUs to your original phyloseq objects
we are only focusing on soil samples for neutral models since they have full replication (all treatments = 6)
also, we are only looking into the ASVs classified as above neutral in each of the treatment splits. this simplifies the analysis and is ultimatetly our focus - subsets selected by treatments
## 8.3.1 is_above_expected


```{r}

# these objects only have the ASVs classified as above_neutral in ANY of the 4 treatments
uni_4model_BO_above
uni_4model_AT_above

# are the taxa of the main physeq object in the physeq object only with above_expected ASV?
# create a logical vector with the awnser
AT_above_vector <- taxa_names(ASV_importance_physeq_list$Arabidopsis_thaliana.Soil) %in% taxa_names(uni_4model_AT_above)
BO_above_vector <- taxa_names(ASV_importance_physeq_list$Brassica_oleraceae.Soil) %in% taxa_names(uni_4model_BO_above)


# take the soil samples, and give a 1/0 tag if the ASV was tagged as above occurence at least once
above_neutral_tags <- mapply(function(x, y) {
  as.data.frame(tax_table(x)) %>% # turn phyloseq object into a dataframe so mutate can work
    mutate(is_above_expected = if_else(condition = y, # if TRUE on y (list of AT_above_vector and BO_above_vector)...
      true = 1, # give value 1, or else..
      false = 0
    )) %>% # give value 0
    as.matrix() %>% # turn dataframe into a matrix...
    tax_table()
}, # turn matrix into datatable
x = ASV_importance_physeq_list[(c(2, 4))], # only elements 2 and 4 of original list (AT_soil BO_soil)
y = list(AT_above_vector, BO_above_vector), # list of logical statements defined above
SIMPLIFY = FALSE
)

# incomplete output
above_neutral_tags


view(above_neutral_tags$Brassica_oleraceae.Soil)
```

## 8.3.2 above_in_2_treatments_absent_control  and above_only_in_control
based on  6.6.6 - add venn diagram shared ASV lists to the node proprieties ####

```{r}
# generate list of shared above-expected ASVs for BO and AT
venn_asv_list_BO <- ps_venn(uni_4model_BO_above, "MeJA_treatment", plot = FALSE)
venn_asv_list_AT <- ps_venn(uni_4model_AT_above, "MeJA_treatment", plot = FALSE)

# vector of shared treatments
shared_treat <- c("MeJA_0.1__MeJA_1.0__oral_secretion", "MeJA_0.1__MeJA_1.0", "MeJA_0.1__oral_secretion", "MeJA_1.0__oral_secretion")





# we want a new taxa classification propriety named "above_expected_in" which shows in which treatments is this ASV occuring above expected values.  this function will add this definition for each compartment of the venn diagram
add_venn_compartment_to_physeq <- function(venn_asv_list, physeq_not_listed) {
  lapply(names(venn_asv_list), function(x) {
    mutate(filter(
      as.data.frame(tax_table(physeq_not_listed)), # base input object
      taxa_names(physeq_not_listed) %in% venn_asv_list[[x]]
    ), # taxa names present in the phyloseq object and in the slice of the venn list
    above_expected_in = paste(x)
    ) # this assings the Venn diagram compartment to the ASVs in the node df
  })
}




############################################################################################################
############ apply custom function and tag definition to AT_soil. ##########################################
############################################################################################################

venn_list_physeq_AT <- add_venn_compartment_to_physeq(
  venn_asv_list = venn_asv_list_AT,
  physeq_not_listed = ASV_importance_physeq_list$Arabidopsis_thaliana.Soil
)



# now merge that list into a single dataframe, removing the other node metrics in AT_soil....
venn_compartments_AT <- as.data.frame(do.call(rbind, venn_list_physeq_AT))["above_expected_in"]



# no give the 2 new tag 1/0 definitions for AT_soil
venn_compartments_AT <- mutate(venn_compartments_AT,
  above_in_2_treatments_absent_control = if_else( # create new varible
    condition = venn_compartments_AT$above_expected_in %in% shared_treat, # in logical vector..
    true = 1,
    false = 0
  ),
  above_only_in_control = if_else( # create another enw variable
    condition = venn_compartments_AT$above_expected_in == "control", # in logical vector..
    true = 1,
    false = 0
  )
) %>% # and then...
  as.matrix() %>% # coerce it into a matrix
  tax_table() # turn it into a phyloseq object tax table




############################################################################################################
################# repeat the code to apply it to BO_soil. ##################################################
############################################################################################################

venn_list_physeq_BO <- add_venn_compartment_to_physeq(
  venn_asv_list = venn_asv_list_BO,
  physeq_not_listed = ASV_importance_physeq_list$Brassica_oleraceae.Soil
)



# now merge that list into a single dataframe, removing the other node metrics in AT_soil....
venn_compartments_BO <- as.data.frame(do.call(rbind, venn_list_physeq_BO))["above_expected_in"]


# create new variable on the new df
venn_compartments_BO <- mutate(venn_compartments_BO,
  above_in_2_treatments_absent_control = if_else( # create new varible
    condition = venn_compartments_BO$above_expected_in %in% shared_treat, # in logical vector..
    true = 1,
    false = 0
  ),
  above_only_in_control = if_else( # create another enw variable
    condition = venn_compartments_BO$above_expected_in == "control", # in logical vector..
    true = 1,
    false = 0
  )
) %>% # and then...
  as.matrix() %>% # coerce it into a matrix
  tax_table() # turn it into a phyloseq object tax table





# merge into a single phyloseq list of above_neutral classifications
above_neutral_tags <- mapply(function(x, y) {
  merge_phyloseq(x, y)
},
x = above_neutral_tags, # this is the output 1 from chunk 8.3.1 ; it is updated with new output
y = list(venn_compartments_AT, venn_compartments_BO),
SIMPLIFY = FALSE
)


# output
above_neutral_tags
```

## 8.3.3 Above expected as coded in networks
This definition follows the legend on the network plot: we should tag ASVs present in:
1) all treatment but not in controls
2) above expected in 1-2 treatments, but not in control
3) above expected in all treatments and control
WARNING! This code may overlap the conde in the previous chunk!

```{r}
# generate list of shared above-expected ASVs for BO and AT
venn_asv_list_BO <- ps_venn(uni_4model_BO_above, "MeJA_treatment", plot = FALSE)
venn_asv_list_AT <- ps_venn(uni_4model_AT_above, "MeJA_treatment", plot = FALSE)

# vector of shared treatments
shared_treat2 <- c(
  "MeJA_0.1__MeJA_1.0__oral_secretion",
  "MeJA_0.1__MeJA_1.0",
  "MeJA_0.1__oral_secretion",
  "MeJA_1.0__oral_secretion",
  "control__MeJA_0.1__MeJA_1.0__oral_secretion",
  "MeJA_0.1",
  "MeJA_1.0",
  "oral_secretion"
)





# we want a new taxa classification propriety named "above_expected_in" which shows in which treatments is this ASV occuring above expected values.  this function will add this definition for each compartment of the venn diagram
add_venn_compartment_to_physeq <- function(venn_asv_list, physeq_not_listed) {
  lapply(names(venn_asv_list), function(x) {
    mutate(filter(
      as.data.frame(tax_table(physeq_not_listed)), # base input object
      taxa_names(physeq_not_listed) %in% venn_asv_list[[x]]
    ), # taxa names present in the phyloseq object and in the slice of the venn list
    above_expected_in = paste(x)
    ) # this assings the Venn diagram compartment to the ASVs in the node df
  })
}




############################################################################################################
############ apply custom function and tag definition to AT_soil. ##########################################
############################################################################################################

venn_list_physeq_AT <- add_venn_compartment_to_physeq(
  venn_asv_list = venn_asv_list_AT,
  physeq_not_listed = ASV_importance_physeq_list$Arabidopsis_thaliana.Soil
)



# now merge that list into a single dataframe, removing the other node metrics in AT_soil....
venn_compartments_AT <- as.data.frame(do.call(rbind, venn_list_physeq_AT))["above_expected_in"]



# now give the 2 a tag 1/0 definitions for AT_soil
venn_compartments_AT <- mutate(venn_compartments_AT,
  above_as_tagged_in_network = if_else( # create new varible
    condition = venn_compartments_AT$above_expected_in %in% shared_treat2, # in logical vector..
    true = 1,
    false = 0
  )
) %>% # and then...
  as.matrix() %>% # coerce it into a matrix
  tax_table() # turn it into a phyloseq object tax table



############################################################################################################
################# repeat the code to apply it to BO_soil. ##################################################
############################################################################################################

venn_list_physeq_BO <- add_venn_compartment_to_physeq(
  venn_asv_list = venn_asv_list_BO,
  physeq_not_listed = ASV_importance_physeq_list$Brassica_oleraceae.Soil
)



# now merge that list into a single dataframe, removing the other node metrics in AT_soil....
venn_compartments_BO <- as.data.frame(do.call(rbind, venn_list_physeq_BO))["above_expected_in"]


# create new variable on the new df
venn_compartments_BO <- mutate(venn_compartments_BO,
  above_as_tagged_in_network = if_else( # create new varible
    condition = venn_compartments_BO$above_expected_in %in% shared_treat2, # in logical vector..
    true = 1,
    false = 0
  )
) %>% # and then...
  as.matrix() %>% # coerce it into a matrix
  tax_table() # turn it into a phyloseq object tax table





# merge into a single phyloseq list of above_neutral classifications
above_neutral_tags <- mapply(function(x, y) {
  merge_phyloseq(x, y)
},
x = above_neutral_tags, # this is the output 1 from chunk 8.3.1 ; it is updated with new output
y = list(venn_compartments_AT, venn_compartments_BO),
SIMPLIFY = FALSE
)


# output
above_neutral_tags
```

# 8.4 -  DIFFERENTIAL ABUNDANCE ###############################################
based on 5.4 add differential abudance classification to phyloseq object 
## 8.4.1 - abundant_in_treatment 1/0 and abundant_in_control 1/0
```{r}


########### automate
# i need 4 lists (sp/niche) of OTUs that are differential related to contorl or not
# this classification will be simplified: is it more abundant in any treatment when compared to control?
# this way they can be ploted on the network or other visualizations/tables



# puts all sigtabs from one environment in only 2 strings...
abundant_taxa_list <- mapply(function(x, y, z) {
  # the input here is the output of the build_sig_tab() custom function

  # get the row names, but only of ASVs that satisfity the condition based on size of logfold change
  abundand_in_treatment1 <- row.names(x[x$log2FoldChange > 0, ]) # more common in treatment
  abundand_in_control1 <- row.names(x[x$log2FoldChange < 0, ]) # more common in control

  abundand_in_treatment2 <- row.names(y[y$log2FoldChange > 0, ]) # more common in treatment
  abundand_in_control2 <- row.names(y[y$log2FoldChange < 0, ]) # more common in control

  abundand_in_treatment3 <- row.names(z[z$log2FoldChange > 0, ]) # more common in treatment
  abundand_in_control3 <- row.names(z[z$log2FoldChange < 0, ]) # more common in control

  # redeplicate, removing repetitive ASV entries
  abundand_in_treatment <- unique(c(abundand_in_treatment1, abundand_in_treatment2, abundand_in_treatment3))
  abundand_in_control <- unique(c(abundand_in_control1, abundand_in_control2, abundand_in_control3))

  # put it into a list, and  give names to the list portions
  output <- list(abundand_in_treatment, abundand_in_control)
  names(output) <- c("abundand_in_treatment", "abundand_in_control")

  return(output)
},
x = Sigtab1,
y = Sigtab2,
z = Sigtab3,
SIMPLIFY = FALSE
)




# this makes a new phyloseq object, adding the deseq2 classifications over a list
list_ps_with_deseq2 <- mapply(function(list_ps_object, abundant_taxa_list_output) {
  output <- mutate( # make a new df wiht a new column...
    as.data.frame(tax_table(list_ps_object)), # on the dataframe-converted  taxa table of your phyloseq object,
    deseq2_ASV_class = if_else( # the new column is named deseq2_ASV_class...
      taxa_names(list_ps_object) %in%
        abundant_taxa_list_output$abundand_in_treatment == TRUE, "abundant_in_treatment", if_else( # if the taxa name is on the list of taxa classified as abudand in treatment, give this claissification on the enw variable, or else...
        taxa_names(list_ps_object) %in%
          abundant_taxa_list_output$abundand_in_control == TRUE, "abundant_in_control", "non-differential"
      )
    )
  ) # check if the taxa is abundant in control and add the tag. if it is not in the list, tag it as non-differential
  tax_table(list_ps_object) <- merge_phyloseq(list_ps_object, tax_table(as.matrix(output))) # now update the tax_table of the original phyloseq object
},
list_ps_object = ASV_importance_physeq_list,
abundant_taxa_list_output = abundant_taxa_list,
SIMPLIFY = FALSE
)


# this will make 2 new varibles with 1/0 for presence/absence as differential abundant in either control or treatments
list_ps_with_deseq2 <- lapply(list_ps_with_deseq2, function(x) {
  as.data.frame(tax_table(x)) %>%
    mutate(
      abundant_in_treatment = if_else(condition = as.data.frame(tax_table(x))$deseq2_ASV_class == "abundant_in_treatment",
        true = 1,
        false = 0
      ),
      abundant_in_control = if_else(condition = as.data.frame(tax_table(x))$deseq2_ASV_class == "abundant_in_control",
        true = 1,
        false = 0
      )
    ) %>%
    as.matrix() %>%
    tax_table()
})

# incomplete output
list_ps_with_deseq2
```

## 8.4.2 - abundant_in_2_treatments_simultaneously 1/0 
add variable that tells if an OTU is classified as abundant_in_2_treatments_simultaneously in 2 different treatments simultaneously
```{r}

# puts all sigtabs from one environment in only 2 strings...
abundant_in_2_treatments <- mapply(function(x, y, z) {
  # the input here is the output of the build_sig_tab() custom function

  # get the row names, but only of ASVs that satisfity the condition based on size of logfold change
  abundand_in_MeJA_0.1 <- row.names(x[x$log2FoldChange > 0, ]) # more common in treatment

  abundand_in_MeJA_1.0 <- row.names(y[y$log2FoldChange > 0, ]) # more common in treatment

  abundand_in_oral_secretion <- row.names(z[z$log2FoldChange > 0, ]) # more common in treatment

  shared_1 <- intersect(abundand_in_MeJA_0.1, abundand_in_MeJA_1.0) # gets shared otus...
  shared_2 <- intersect(abundand_in_oral_secretion, abundand_in_MeJA_1.0) # gets shared otus...
  shared_3 <- intersect(abundand_in_oral_secretion, abundand_in_MeJA_0.1) # gets shared otus...

  # redeplicate, removing repetitive ASV entries
  abundand_in_treatment <- unique(c(shared_1, shared_2, shared_3))

  return(abundand_in_treatment)
},
x = Sigtab1,
y = Sigtab2,
z = Sigtab3,
SIMPLIFY = FALSE
)




# this will make 1 new varibles with 1/0 for presence/absesnce as differential abundant in 2 treatments simultaneously
list_ps_with_deseq2 <- mapply(function(x, y) {
  as.data.frame(tax_table(x)) %>%
    mutate(abundant_in_2_treatments_simultaneously = if_else(condition = row.names(as.data.frame(tax_table(x))) %in% y,
      true = 1,
      false = 0
    )) %>%
    as.matrix() %>%
    tax_table()
},
x = list_ps_with_deseq2, # this is the output from 8.4.1, updated with new variable
y = abundant_in_2_treatments,
SIMPLIFY = FALSE
)



# output
list_ps_with_deseq2
```



# 8.5 - merge tax_table of classifications into the same phyloseq object
```{r}




# original object
ASV_importance_physeq_list

# RF output
rf_added_tax

# network output
network_tags

# neutral_model output
above_neutral_tags

# abundant ASV output
list_ps_with_deseq2



# now we merge the abse phyloseq object with all classifications excepet for the neutral models, that should only be applied to the soil samples
ASV_importance_physeq_list_merged <- mapply(function(x, y, z, w) {
  merge_phyloseq(x, y, z, w)
},
x = ASV_importance_physeq_list,
y = rf_added_tax,
z = network_tags,
w = list_ps_with_deseq2,
SIMPLIFY = FALSE
)

# now, update only the soil samples with the neutral model categories
ASV_importance_physeq_list_merged[c(2, 4)] <- mapply(function(x, y) {
  merge_phyloseq(x, y)
},
x = ASV_importance_physeq_list_merged[c(2, 4)],
y = above_neutral_tags,
SIMPLIFY = FALSE
)
```

# 8.6a - adjust merged tax_classifications (NAs, numeric vectors)

```{r}
# remove NA's.
ASV_importance_physeq_list_merged <- lapply(ASV_importance_physeq_list_merged, function(x) {
  replace_na(
    data = tax_table(x),
    replace = 0
  )
})

# make a df version so we can change factor sna make calculations with mutate
ASV_importance_physeq_list_merged_df <- lapply(ASV_importance_physeq_list_merged, function(x) {
  as.data.frame(tax_table(x))
})

# give 0 scores to neutral model classification on root data partitions. it will facilitate looping over variables laters instead of treating roots and soils as different things
ASV_importance_physeq_list_merged_df[c(1, 3)] <- lapply(ASV_importance_physeq_list_merged_df[c(1, 3)], function(x) {
  mutate(x,
    is_above_expected = 0,
    above_in_2_treatments_absent_control = 0,
    above_only_in_control = 0,
    above_as_tagged_in_network = 0
  )
})


scoring_variables <- c(
  "important_in_rf", # random forest def
  "is_keystone_taxa", "is_module_hub", "is_module_connector", # network def
  "abundant_in_treatment", "abundant_in_control", "abundant_in_2_treatments_simultaneously", # deseq2 def
  "is_above_expected", "above_in_2_treatments_absent_control", "above_only_in_control", "above_as_tagged_in_network"
) # neutral  def

# makes df only containing the imporance scores, as numeric variables
ASV_importance_scores <- lapply(ASV_importance_physeq_list_merged_df, function(x) {
  x[scoring_variables] %>%
    mutate_if(is.character, as.numeric)
})

# output
ASV_importance_scores
```


# 8.6.1b - simplified merged tax_classifications (4presence/absence columns for the 4 methods)

```{r}

# take the importance scores, and reduce them to only 4 columsn while creating new variables based on them
# for future applications of similar code, this can be simplified so we don't create output we don't use in the end
simplified_ASV_importance_scores <- lapply(ASV_importance_scores, function(x) {
  mutate(x,
    has_network_tag = rowSums(x[, 2:4]), # merged the network tags
    is_differentially_abundant = rowSums(x[, 5:6])
  ) %>% # merged the deseqq tags
    select(important_in_rf, above_as_tagged_in_network, has_network_tag, is_differentially_abundant)
}) # select a part of the df

# NOTE: ON jAN/2022 PEDRO FILTERED THE ABOVE EXPECTED. INSTEAD OF ACCEPTING ALL ASVS WITH ANY TAG, NOW WE ONLY INCLUDE ASVS AS TAGGED IN THE NETWORK


# NOTE: BO_soil has 3 ASVs with 2 network tags simultaneously. with this line, we adjust it's sum to 1
simplified_ASV_importance_scores$Brassica_oleraceae.Soil$has_network_tag[(simplified_ASV_importance_scores$Brassica_oleraceae.Soil$has_network_tag == 2)] <- 1





# generate a simple sum of tags column
simplified_ASV_importance_scores <- lapply(simplified_ASV_importance_scores, function(x) {
  mutate(x, sum_of_tags = rowSums(x))
}) # new variable with rowsums...

# now sort the new df based on the sum of tags
simplified_ASV_importance_scores <- lapply(simplified_ASV_importance_scores, function(x) {
  x[order(x$sum_of_tags, decreasing = TRUE), ]
})
# output
simplified_ASV_importance_scores
```



```{r}
# this is the object we actualy need for the next script
simplified_ASV_importance_scores
```



# overwrite saved session
```{r}

save.image("./R output/analysis_session.RData")

```

a lsit fo importnat ASVs has been defined. proceed to script 9_important_taxa_overrepresentation!





