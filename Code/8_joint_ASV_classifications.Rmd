---
title: "8_joint_ASV_classifications"
author: "Pedro"
date: "11/10/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

In the previous scripts, we could classify our OTUs as above neutral, differential, importnat in random forest, keystone, etc.

On this script, we will put all these classifications together so we have a final rank of ASV_importance in the experimental design. We are interested in both relevance to any treatment and relevance to control, so we can compare putative functions.

#
#data splits
we will use the 4-split dataset, with relevance_ranks for each OTU at each data split. 
in the end, we will have also a final cummulative OTU_relevance rank

#relevance_ranks types
number_of_flags: one of the ranks will record how many flags (keystone,a bove expected, etc) an OTU has, by simple counting/addition
rarity_of_flags: The other ranking will quantify that according occurrence of the task (if 1 in 100 OTUs have that rank, add 100 to the otu_relevance)
  rarity_of_flags_total: defines the rarity of flags across the total OTU number ( ~ 4572  taxa)
  rarity_of_flags_slice: defines the rarity of flags across the 4-split data slice
  
Balanced_rarity_of_flags: sum of rarify of flag, divided by the number of flag categories within that method, and then diveded evenly across number of methods

#methods ranking
Random forest: (4-split input)
        is this feature selected by Borura as important? 1/0

  
Network: (4-split input)
        is this feature a keystone? 1/0
        is it a module hub? 1/0
        is it a connector? 1/0
        (is it in a module correlated to qPCR data? 1/0,  i'm no sure I should add metadata here if I'm not adding elswhere) 
        
Differential abundance: 
        Is this OTU more abundant in any treatment compared to the control? 1/0
        Is this OTU more abundant in the control? 1/0
        Is this differentially abundant OTU shared between Oral_secreation and any MeJA treatment? 1/0
        
Neutral model: (focus on above_expected for simplicity)
        Is this OTU occuring above_expected? 1/0 (ready)
        if above_expected, is it found outside control?
        if above_expected, is it shared between Oral_secreation and the two MeJA treatments? 1/0
        if above_expected, is it found inside control?
        if above_expected, is it found only in control?

```{r}
#first, let;s make a new physeq object we can alter in this script without messing up the original object
ASV_importance_physeq_list<-ps_list_rarefied

```




# 8.1 - RANDOM FOREST ################################################

based on 7.4 add the rf classification as part of the OTU taxonomy

If the ASV is classified as important by boruta on scrip 7, give score 1 on the variable "important_in_rf", or else score 0

```{r boruta}

# add the rf classification as part of the OTU taxonomy  to a list of phyloseq objects      
rf_added_tax<-mapply(function (x,y)
  tax_table(x)%>% #get tax table of the phyloseq object...
  as.data.frame()%>% # turn it into a dataframe so mutate can work
mutate(important_in_rf = # make anew variable caled random_forest_relevance, where...
         if_else(taxa_names(x)%in%y == TRUE,1, 0)),# if the taxa names are present in the boruta list of selected ASVs, tag them as inportant
  x =ASV_importance_physeq_list,
  y =boruta_ASV_list, 
  SIMPLIFY = FALSE)       

#now this is a phyloseq object  (df turned into amatrix)    
rf_added_tax<-lapply(rf_added_tax, function (x) tax_table(as.matrix(x)))

#output
rf_added_tax

```

# 8.2 - NETWORK ANALYSIS

base on script 6.8 - Export network data, utilizing the object complete_node_metrics_withFitClass

makes 3 new variables, giving value of 1 if they are classified as keystone, module hub, or module connector. If they don't have this tag, give value 0

```{r}

# all the node merics from the netowrk analysis
complete_node_metrics_withFitClass

# asing 1/0 for presence absence
# BUG: for some reason, complete_node_metrics_withFitClass$Arabidopsis_thaliana.Root$Zi has " 0" instead of "0"
# this also happens for the keystone definition on other data partitions
# this if fixed if I make it true = "1" instead of true = 1. I will use this dirty fix for now
network_tags<-lapply(complete_node_metrics_withFitClass, function (x) 
  mutate(x, is_module_hub = if_else(condition = x$Zi>=2.5,
                                    true = "1", 
                                    false = "0"))) #make new variable is_module_hub, based on Zi values

network_tags<-lapply(network_tags, function (x) 
  mutate(x, is_module_connector = if_else(condition = x$Pi>=0.62,
                                    true = 1, 
                                    false = 0))) #make new variable is_module_hub, based on Pi values

network_tags<-lapply(network_tags, function (x) 
  mutate(x, is_keystone_taxa  = if_else(condition = x$keystone_taxa=="Keystone",
                                    true = "1", 
                                    false = "0"))) #updates keystone variable is_module_hub, based on keystone tag


#bug: for some reason, complete_node_metrics_withFitClass$Arabidopsis_thaliana.Root$Zi has " 0" instead of "0"


# remove uncessary network metrics and turn it into a phyloseq object
network_tags<-lapply(network_tags, function (x) #for each emeber of this lsit....
  select(x, Row.names, is_keystone_taxa,is_module_hub,is_module_connector,DADA2_ID )%>% #select some of the variables, and then...
    column_to_rownames(var ="Row.names")%>% # turn the Row.Names vector into actual rownames, then...
    as.matrix()%>% # then force it into a matrix to fit tax_table, then..
    tax_table()# make it a tax_table phyloseq object
    )

#output
network_tags

```

# 8.3 - NEUTRAL MODELS ###############################################3
based on 4.5 Add neutral fit classes of OTUs to your original phyloseq objects
we are only focusing on soil samples for neutral models since they have full replication (all treatments = 6)
also, we are only looking into the ASVs classified as above neutral in each of the treatment splits. this simplifies the analysis and is ultimatetly our focus - subsets selected by treatments
## 8.3.1 is_above_expected


```{r}

# these objects only have the ASVs classified as above_neutral in ANY of the 4 treatments
uni_4model_BO_above
uni_4model_AT_above

# are the taxa of the main physeq object in the physeq object only with above_expected ASV?
# create a logical vector with the awnser
AT_above_vector<-taxa_names(ASV_importance_physeq_list$Arabidopsis_thaliana.Soil)%in%taxa_names(uni_4model_AT_above) 
BO_above_vector<-taxa_names(ASV_importance_physeq_list$Brassica_oleraceae.Soil)%in%taxa_names(uni_4model_BO_above) 


# take the soil samples, and give a 1/0 tag if the ASV was tagged as above occurence at least once
above_neutral_tags<-mapply(function (x,y)
  as.data.frame(tax_table(x))%>% # turn phyloseq object into a dataframe so mutate can work
  mutate(is_above_expected = if_else(condition = y, # if TRUE on y (list of AT_above_vector and BO_above_vector)...
                                     true = 1, # give value 1, or else..
                                     false = 0))%>% # give value 0
  as.matrix()%>% # turn dataframe into a matrix...
  tax_table(), # turn matrix into datatable
  x = ASV_importance_physeq_list[(c(2,4))], #only elements 2 and 4 of original list (AT_soil BO_soil)
  y = list(AT_above_vector,BO_above_vector), # list of logical statements defined above
  SIMPLIFY = FALSE)

#incomplete output 
above_neutral_tags


view(above_neutral_tags$Brassica_oleraceae.Soil)

```

## 8.3.2 above_in_2_treatments_absent_control  and above_only_in_control
based on  6.6.6 - add venn diagram shared ASV lists to the node proprieties ####

```{r}
#generate list of shared above-expected ASVs for BO and AT
venn_asv_list_BO<-ps_venn(uni_4model_BO_above,"MeJA_treatment", plot = FALSE)
venn_asv_list_AT<-ps_venn(uni_4model_AT_above,"MeJA_treatment", plot = FALSE)

# vector of shared treatments    
shared_treat<-c("MeJA_0.1__MeJA_1.0__oral_secretion","MeJA_0.1__MeJA_1.0", "MeJA_0.1__oral_secretion" , "MeJA_1.0__oral_secretion") 





# we want a new taxa classification propriety named "above_expected_in" which shows in which treatments is this ASV occuring above expected values.  this function will add this definition for each compartment of the venn diagram
add_venn_compartment_to_physeq<-function(venn_asv_list, physeq_not_listed){
  lapply(names(venn_asv_list), function(x) {
mutate(filter(as.data.frame(tax_table(physeq_not_listed)), #base input object
              taxa_names(physeq_not_listed)%in%venn_asv_list[[x]]), #taxa names present in the phyloseq object and in the slice of the venn list
       above_expected_in=paste(x)) # this assings the Venn diagram compartment to the ASVs in the node df
  })
}




############################################################################################################
############ apply custom function and tag definition to AT_soil. ########################################## 
############################################################################################################

venn_list_physeq_AT<-add_venn_compartment_to_physeq(venn_asv_list =venn_asv_list_AT, 
                               physeq_not_listed = ASV_importance_physeq_list$Arabidopsis_thaliana.Soil)



#now merge that list into a single dataframe, removing the other node metrics in AT_soil....
venn_compartments_AT<-as.data.frame(do.call(rbind, venn_list_physeq_AT))["above_expected_in"]



#no give the 2 new tag 1/0 definitions for AT_soil
venn_compartments_AT<-mutate(venn_compartments_AT, 
                        above_in_2_treatments_absent_control = if_else( #create new varible
                                condition = venn_compartments_AT$above_expected_in%in%shared_treat, # in logical vector..
                                true = 1,
                                false = 0),
                         above_only_in_control = if_else( #create another enw variable
                                condition = venn_compartments_AT$above_expected_in =="control", # in logical vector..
                                true = 1,
                                false = 0))%>% # and then...
                      as.matrix()%>% #coerce it into a matrix
                      tax_table() # turn it into a phyloseq object tax table




############################################################################################################
################# repeat the code to apply it to BO_soil. ################################################## 
############################################################################################################

venn_list_physeq_BO<-add_venn_compartment_to_physeq(venn_asv_list =venn_asv_list_BO, 
                               physeq_not_listed = ASV_importance_physeq_list$Brassica_oleraceae.Soil)
    


#now merge that list into a single dataframe, removing the other node metrics in AT_soil....
venn_compartments_BO<-as.data.frame(do.call(rbind, venn_list_physeq_BO))["above_expected_in"]


# create new variable on the new df
venn_compartments_BO<-mutate(venn_compartments_BO, 
                        above_in_2_treatments_absent_control = if_else( #create new varible
                                condition = venn_compartments_BO$above_expected_in%in%shared_treat, # in logical vector..
                                true = 1,
                                false = 0),
                         above_only_in_control = if_else( #create another enw variable
                                condition = venn_compartments_BO$above_expected_in =="control", # in logical vector..
                                true = 1,
                                false = 0))%>% # and then...
                      as.matrix()%>% #coerce it into a matrix
                      tax_table() # turn it into a phyloseq object tax table





# merge into a single phyloseq list of above_neutral classifications
above_neutral_tags<-mapply(function(x,y)
  merge_phyloseq (x,y),
x = above_neutral_tags, #this is the output 1 from chunk 8.3.1 ; it is updated with new output
y = list(venn_compartments_AT,venn_compartments_BO),
SIMPLIFY = FALSE)


#output 
above_neutral_tags


```

## 8.3.3 Above expected as coded in networks
This definition follows the legend on the network plot: we should tag ASVs present in:
1) all treatment but not in controls
2) above expected in 1-2 treatments, but not in control
3) above expected in all treatments and control
WARNING! This code may overlap the conde in the previous chunk!

```{r}
#generate list of shared above-expected ASVs for BO and AT
venn_asv_list_BO<-ps_venn(uni_4model_BO_above,"MeJA_treatment", plot = FALSE)
venn_asv_list_AT<-ps_venn(uni_4model_AT_above,"MeJA_treatment", plot = FALSE)

# vector of shared treatments    
shared_treat2<-c("MeJA_0.1__MeJA_1.0__oral_secretion",
                "MeJA_0.1__MeJA_1.0", 
                "MeJA_0.1__oral_secretion" , 
                "MeJA_1.0__oral_secretion",
                "control__MeJA_0.1__MeJA_1.0__oral_secretion",
                "MeJA_0.1",
                "MeJA_1.0",
                "oral_secretion"
                ) 





# we want a new taxa classification propriety named "above_expected_in" which shows in which treatments is this ASV occuring above expected values.  this function will add this definition for each compartment of the venn diagram
add_venn_compartment_to_physeq<-function(venn_asv_list, physeq_not_listed){
  lapply(names(venn_asv_list), function(x) {
mutate(filter(as.data.frame(tax_table(physeq_not_listed)), #base input object
              taxa_names(physeq_not_listed)%in%venn_asv_list[[x]]), #taxa names present in the phyloseq object and in the slice of the venn list
       above_expected_in=paste(x)) # this assings the Venn diagram compartment to the ASVs in the node df
  })
}




############################################################################################################
############ apply custom function and tag definition to AT_soil. ########################################## 
############################################################################################################

venn_list_physeq_AT<-add_venn_compartment_to_physeq(venn_asv_list =venn_asv_list_AT, 
                               physeq_not_listed = ASV_importance_physeq_list$Arabidopsis_thaliana.Soil)



#now merge that list into a single dataframe, removing the other node metrics in AT_soil....
venn_compartments_AT<-as.data.frame(do.call(rbind, venn_list_physeq_AT))["above_expected_in"]



#now give the 2 a tag 1/0 definitions for AT_soil
venn_compartments_AT<-mutate(venn_compartments_AT, 
                        above_as_tagged_in_network = if_else( #create new varible
                                condition = venn_compartments_AT$above_expected_in%in%shared_treat2, # in logical vector..
                                true = 1,
                                false = 0))%>% # and then...
                      as.matrix()%>% #coerce it into a matrix
                      tax_table() # turn it into a phyloseq object tax table



############################################################################################################
################# repeat the code to apply it to BO_soil. ################################################## 
############################################################################################################

venn_list_physeq_BO<-add_venn_compartment_to_physeq(venn_asv_list =venn_asv_list_BO, 
                               physeq_not_listed = ASV_importance_physeq_list$Brassica_oleraceae.Soil)
    


#now merge that list into a single dataframe, removing the other node metrics in AT_soil....
venn_compartments_BO<-as.data.frame(do.call(rbind, venn_list_physeq_BO))["above_expected_in"]


# create new variable on the new df
venn_compartments_BO<-mutate(venn_compartments_BO, 
                        above_as_tagged_in_network = if_else( #create new varible
                                condition = venn_compartments_BO$above_expected_in%in%shared_treat2, # in logical vector..
                                true = 1,
                                false = 0))%>% # and then...
                      as.matrix()%>% #coerce it into a matrix
                      tax_table() # turn it into a phyloseq object tax table





# merge into a single phyloseq list of above_neutral classifications
above_neutral_tags<-mapply(function(x,y)
  merge_phyloseq (x,y),
x = above_neutral_tags, #this is the output 1 from chunk 8.3.1 ; it is updated with new output
y = list(venn_compartments_AT,venn_compartments_BO),
SIMPLIFY = FALSE)


#output 
above_neutral_tags


```

# 8.4 -  DIFFERENTIAL ABUNDANCE ###############################################
based on 5.4 add differential abudance classification to phyloseq object 
## 8.4.1 - abundant_in_treatment 1/0 and abundant_in_control 1/0
```{r}


########### automate
# i need 4 lists (sp/niche) of OTUs that are differential related to contorl or not
# this classification will be simplified: is it more abundant in any treatment when compared to control?
# this way they can be ploted on the network or other visualizations/tables



# puts all sigtabs from one environment in only 2 strings...
abundant_taxa_list<-mapply (function (x, y,z){
# the input here is the output of the build_sig_tab() custom function  
  
#get the row names, but only of ASVs that satisfity the condition based on size of logfold change
abundand_in_treatment1<-row.names(x[x$log2FoldChange>0,]) #more common in treatment
abundand_in_control1<-row.names(x[x$log2FoldChange<0,]) #more common in control

abundand_in_treatment2<-row.names(y[y$log2FoldChange>0,]) #more common in treatment
abundand_in_control2<-row.names(y[y$log2FoldChange<0,]) #more common in control

abundand_in_treatment3<-row.names(z[z$log2FoldChange>0,]) #more common in treatment
abundand_in_control3<-row.names(z[z$log2FoldChange<0,]) #more common in control

#redeplicate, removing repetitive ASV entries
abundand_in_treatment<-unique(c(abundand_in_treatment1, abundand_in_treatment2,abundand_in_treatment3))
abundand_in_control<-unique(c(abundand_in_control1, abundand_in_control2,abundand_in_control3))

# put it into a list, and  give names to the list portions
output<-list(abundand_in_treatment,abundand_in_control)
names(output)<-c("abundand_in_treatment","abundand_in_control" )

return(output)

},
  x = Sigtab1, 
  y = Sigtab2,
  z = Sigtab3,
  SIMPLIFY = FALSE)




# this makes a new phyloseq object, adding the deseq2 classifications over a list
list_ps_with_deseq2<-mapply(function (list_ps_object,abundant_taxa_list_output){
  output<-mutate( #make a new df wiht a new column...
  as.data.frame(tax_table(list_ps_object)), # on the dataframe-converted  taxa table of your phyloseq object,
       deseq2_ASV_class = if_else( # the new column is named deseq2_ASV_class...
         taxa_names(list_ps_object)%in%
           abundant_taxa_list_output$abundand_in_treatment == TRUE , "abundant_in_treatment", if_else( #if the taxa name is on the list of taxa classified as abudand in treatment, give this claissification on the enw variable, or else...
             taxa_names(list_ps_object)%in%
              abundant_taxa_list_output$abundand_in_control == TRUE, "abundant_in_control", "non-differential")))# check if the taxa is abundant in control and add the tag. if it is not in the list, tag it as non-differential
     tax_table(list_ps_object)<-merge_phyloseq(list_ps_object, tax_table(as.matrix(output))) #now update the tax_table of the original phyloseq object
     
},
  list_ps_object = ASV_importance_physeq_list,
  abundant_taxa_list_output = abundant_taxa_list,
  SIMPLIFY = FALSE)


# this will make 2 new varibles with 1/0 for presence/absence as differential abundant in either control or treatments
list_ps_with_deseq2<-lapply(list_ps_with_deseq2, function (x){
    as.data.frame(tax_table(x))%>%
    mutate(abundant_in_treatment = if_else(condition = as.data.frame(tax_table(x))$deseq2_ASV_class=="abundant_in_treatment",
                                           true = 1,
                                           false = 0 ),
           abundant_in_control = if_else(condition = as.data.frame(tax_table(x))$deseq2_ASV_class=="abundant_in_control",
                                         true = 1,
                                         false = 0))%>%
    as.matrix()%>%
    tax_table()
  })

#incomplete output
list_ps_with_deseq2

```

## 8.4.2 - abundant_in_2_treatments_simultaneously 1/0 
add variable that tells if an OTU is classified as abundant_in_2_treatments_simultaneously in 2 different treatments simultaneously
```{r}

# puts all sigtabs from one environment in only 2 strings...
abundant_in_2_treatments<-mapply (function (x, y,z){
# the input here is the output of the build_sig_tab() custom function  
  
#get the row names, but only of ASVs that satisfity the condition based on size of logfold change
abundand_in_MeJA_0.1<-row.names(x[x$log2FoldChange>0,]) #more common in treatment

abundand_in_MeJA_1.0<-row.names(y[y$log2FoldChange>0,]) #more common in treatment

abundand_in_oral_secretion<-row.names(z[z$log2FoldChange>0,]) #more common in treatment

shared_1<-intersect(abundand_in_MeJA_0.1, abundand_in_MeJA_1.0) # gets shared otus...
shared_2<-intersect(abundand_in_oral_secretion, abundand_in_MeJA_1.0) # gets shared otus...
shared_3<-intersect(abundand_in_oral_secretion, abundand_in_MeJA_0.1) # gets shared otus...

#redeplicate, removing repetitive ASV entries
abundand_in_treatment<-unique(c(shared_1, shared_2,shared_3))

return(abundand_in_treatment)

},
  x = Sigtab1, 
  y = Sigtab2,
  z = Sigtab3,
  SIMPLIFY = FALSE)




# this will make 1 new varibles with 1/0 for presence/absesnce as differential abundant in 2 treatments simultaneously 
list_ps_with_deseq2<-mapply(function (x,y){
    as.data.frame(tax_table(x))%>%
    mutate(abundant_in_2_treatments_simultaneously = if_else(condition =  row.names(as.data.frame(tax_table(x)))%in%y,
                                           true = 1,
                                           false = 0 ))%>%
    as.matrix()%>%
    tax_table()
  },
  x = list_ps_with_deseq2, # this is the output from 8.4.1, updated with new variable
  y = abundant_in_2_treatments,
  SIMPLIFY = FALSE)



#output
list_ps_with_deseq2


```



# 8.5 - merge tax_table of classifications into the same phyloseq object
```{r}




#original object
ASV_importance_physeq_list

#RF output
rf_added_tax

#network output
network_tags

#neutral_model output
above_neutral_tags

# abundant ASV output
list_ps_with_deseq2



# now we merge the abse phyloseq object with all classifications excepet for the neutral models, that should only be applied to the soil samples
ASV_importance_physeq_list_merged<- mapply (function (x,y,z,w)
                                merge_phyloseq(x,y,z,w),
                                  x = ASV_importance_physeq_list,
                                  y = rf_added_tax,
                                  z = network_tags,
                                  w = list_ps_with_deseq2,
                                  SIMPLIFY = FALSE)

# now, update only the soil samples with the neutral model categories
ASV_importance_physeq_list_merged[c(2,4)]<- mapply (function (x,y)
                                merge_phyloseq(x,y),
                                  x = ASV_importance_physeq_list_merged[c(2,4)],
                                  y = above_neutral_tags,
                                  SIMPLIFY = FALSE)

```

# 8.6a - adjust merged tax_classifications (NAs, numeric vectors)

```{r}
# remove NA's.
ASV_importance_physeq_list_merged<- lapply(ASV_importance_physeq_list_merged, function (x)
                                      replace_na(data = tax_table(x),
                                                 replace =0))

#make a df version so we can change factor sna make calculations with mutate
ASV_importance_physeq_list_merged_df<-lapply (ASV_importance_physeq_list_merged, function (x)
                                                as.data.frame(tax_table(x)))

# give 0 scores to neutral model classification on root data partitions. it will facilitate looping over variables laters instead of treating roots and soils as different things
ASV_importance_physeq_list_merged_df[c(1,3)]<-lapply(ASV_importance_physeq_list_merged_df[c(1,3)], function(x)
  mutate(x,
         is_above_expected = 0,
         above_in_2_treatments_absent_control = 0,
         above_only_in_control = 0,
         above_as_tagged_in_network = 0))


scoring_variables<-c("important_in_rf", #random forest def
                      "is_keystone_taxa", "is_module_hub", "is_module_connector", # network def
                      "abundant_in_treatment", "abundant_in_control", "abundant_in_2_treatments_simultaneously", #deseq2 def 
                      "is_above_expected", "above_in_2_treatments_absent_control", "above_only_in_control", "above_as_tagged_in_network") # neutral  def

# makes df only containing the imporance scores, as numeric variables
ASV_importance_scores<-lapply( ASV_importance_physeq_list_merged_df, function (x)
  x[scoring_variables]%>%
  mutate_if(is.character,as.numeric))

#output
ASV_importance_scores

```


# 8.6.1b - simplified merged tax_classifications (4presence/absence columns for the 4 methods)

```{r}

# take the importance scores, and reduce them to only 4 columsn while creating new variables based on them
# for future applications of similar code, this can be simplified so we don't create output we don't use in the end
simplified_ASV_importance_scores<-lapply (ASV_importance_scores, function (x)
                                        mutate(x, has_network_tag = rowSums(x[,2:4]), #merged the network tags
                                                 is_differentially_abundant = rowSums(x[,5:6]))%>% #merged the deseqq tags
         select(important_in_rf, above_as_tagged_in_network, has_network_tag,is_differentially_abundant )) # select a part of the df

# NOTE: ON jAN/2022 PEDRO FILTERED THE ABOVE EXPECTED. INSTEAD OF ACCEPTING ALL ASVS WITH ANY TAG, NOW WE ONLY INCLUDE ASVS AS TAGGED IN THE NETWORK


#NOTE: BO_soil has 3 ASVs with 2 network tags simultaneously. with this line, we adjust it's sum to 1
simplified_ASV_importance_scores$Brassica_oleraceae.Soil$has_network_tag[(simplified_ASV_importance_scores$Brassica_oleraceae.Soil$has_network_tag==2)]<-1





#generate a simple sum of tags column
simplified_ASV_importance_scores<-lapply(simplified_ASV_importance_scores, function (x)
  mutate(x, sum_of_tags = rowSums(x))) # new variable with rowsums...
           
# now sort the new df based on the sum of tags
simplified_ASV_importance_scores<- lapply(simplified_ASV_importance_scores, function(x)
                                                      x[order(x$sum_of_tags, decreasing = TRUE),])
#output
simplified_ASV_importance_scores


```

## 8.6.2b generate a summed scored, based on the rarity of the tag in the dataset
```{r}
############### scored importance on simplified 1/0 input
simplified_ASV_importance_scores$Arabidopsis_thaliana.Root[,5]
# dumbest, lazyiest and most repetitive way of assignign scores  and then summing them  
numeric_simplified_ASV_importance_scores<-lapply(simplified_ASV_importance_scores, function(x){
  
  # wit this, we calculate the score for every variable
  numerator<-nrow(x)
  denominator<-sapply(x, sum)
  asv_score<-numerator/denominator
  
 mutant<-x[,1:4]%>% #mutates several columns, one a a time... sapply() or across() should ahve been able to do this!
    mutate(important_in_rf = if_else(condition = important_in_rf>0, true = asv_score[1], false = 0 ))%>%
    mutate(is_above_expected  = if_else(condition = is_above_expected >0, true = asv_score[2], false = 0 ))%>%
    mutate(has_network_tag = if_else(condition = has_network_tag >0, true = asv_score[3], false = 0 ))%>%
    mutate(is_differentially_abundant  = if_else(condition = is_differentially_abundant >0, true = asv_score[4], false = 0 ))
    
   mutant2<-mutate(mutant, sumed_scores = rowSums(mutant))# sum the scores
   mutant2$sum_of_tags<-x$sum_of_tags # put the sums of tags back into the object
   output<-filter(mutant2,sumed_scores>0)# remove rows wihtout any tag

   output<-output[order(output$sumed_scores, decreasing = TRUE),] #sort according summed scores
  
return(output)
})

#output
numeric_simplified_ASV_importance_scores


```



## 8.6.2b generate a weighted scored, based on the suqare root of the multiplication of the rarity values
```{r}
# multiply the values and take a sqaure root
final_ASV_importance<-lapply(numeric_simplified_ASV_importance_scores, function (x) {
  x[x==0]<-1 # turn zeros into one so they don't disturb multiplication
 output<- mutate(x, sqrt_mult_score = sqrt( x$important_in_rf *
                                   x$is_above_expected *
                                   x$is_differentially_abundant *
                                   x$has_network_tag ))
 output[output==1]<-0 # now turn "1" back into "0" for better redability
    output$sum_of_tags <-x$sum_of_tags # the line above tuns the 1 on sum_of_tags into a zero too but we don't want this. with this line we jsut reconstruct it from the original object
 
   output<-output[order(output$sqrt_mult_score, decreasing = TRUE),] #sort according summed scores

return(output)

})

#output
final_ASV_importance


```



## 8.7.2 Shorten the list of interesting ASVs based on the 3 different scores
after all these calculations and claffifications, there are only 3-6 scores possible for every data partition
```{r}
#here we ahve the summed and multiplied scores
final_ASV_importance

# here we have the additional classifications, such as hub/connector and present in 2 treatments
ASV_importance_scores

# was tagged at all
relevant_ASV<-lapply(final_ASV_importance, function (x) rownames(x))%>%
unlist(use.names=FALSE)%>%
  unique()

# simple bar plot with ASVs that were tagged at all
lapply (ps_list_rarefied, function (x) prune_taxa(relevant_ASV, x)%>%
          plot_bar("MeJA_treatment", fill = "Class"))


#at least 2 tags
two_tags<-lapply(final_ASV_importance, function (x) rownames(filter(x,sum_of_tags>1)))

# add details of scored ASVs
detailed_final_ASV_importance<-mapply (function (x,y){
 selected_var<-select(y, -important_in_rf,-is_above_expected)
  
 output<- merge(x,selected_var, by=0)%>%
   column_to_rownames(var = "Row.names" )
 
 output<-output[order(output$sqrt_mult_score, decreasing = TRUE),] #sort according summed scores
  
  return(output)
},
x=final_ASV_importance,
y=ASV_importance_scores,
SIMPLIFY = FALSE)

#ties must be broken, specially for above_selected and abundant_taxa..... and/or come up with a visualization

# let's get he rownames of above_expected ASVs we want to remove because tehy ahve a single tag and are not exclusively associated to either treatments or controls

detailed_final_ASV_importance_filt_above<-lapply(detailed_final_ASV_importance, function(x){
  remove_this<-rownames(filter(x, #gets rows names of...
       is_above_expected >1 & #is above expected and...
       sum_of_tags==1)%>% #has only 1 tag....
  filter(above_in_2_treatments_absent_control == 0 &# ..and this tag is not related to treatm,,
         above_only_in_control == 0))# nor this tag is related to controls,,

output<-filter(x, !rownames(x) %in% remove_this) # filters the original object, removing the rownmes of  remove_this
return(output)
})


detailed_final_ASV_importance_filt_above_abund<-lapply (detailed_final_ASV_importance_filt_above, function (x) {
 remove_this<-rownames(filter(x, #gets rows names of...
       is_differentially_abundant >1 & #is differentially abundant and...
       sum_of_tags==1 & #has only 1 tag....
        abundant_in_control ==0 & # is not related to the controls... 
       abundant_in_2_treatments_simultaneously == 0 )) # ..and this tag is not related to 2 treatments simultaneously
        
output<-filter(x, !rownames(x) %in% remove_this)
return(output)

 })


# still tagged after filtering
relevant_ASV_filtered<-lapply(final_ASV_importance, function (x) rownames(x))


# simple bar plot with ASVs that were tagged at all
mapply (function (x,y) 
  prune_taxa(y, x)%>%
          plot_bar("Family", facet_grid = "MeJA_treatment"),
x = ps_list_rarefied,
y = two_tags,
SIMPLIFY = FALSE)
```





#construct a heat tree with metacoder::heat_tree
check https://grunwaldlab.github.io/metacoder_documentation/example.html for tutorial
```{r}

install.packages("metacoder")
library("metacoder")
tax_table(ps_list_rarefied$Arabidopsis_thaliana.Root)


test_ps<-ps_list_rarefied$Arabidopsis_thaliana.Root

#aglomerate & remove NA
test_ps<-tax_glom(test_ps, taxrank = "Genus")
test_ps<-phyloseq_rm_na_tax(test_ps)

#jsut remove dada2id & species
tax_table(test_ps)<-tax_table(test_ps)[,1:6]


# transform from phyloseq to  taxmap object
test<-parse_phyloseq(prune_taxa(relevant_ASV_filtered$Arabidopsis_thaliana.Root,
                                test_ps))

#get abundance per taxon
test$data$tax_abund<-calc_taxon_abund(obj = test, 
                                      data = "otu_table",
                                      cols = test$data$sample_data$sample_id)
#get occuence of per sample type
test$data$tax_occ <- calc_n_samples(obj = test, 
                                    data = "tax_abund", 
                                    groups = test$data$sample_data$MeJA_treatment, 
                                    cols = test$data$sample_data$sample_id)
test$data$tax_occ$MeJA_1.0

heat_tree(test,
          node_label = test$taxon_names(),
          node_size = test$n_obs(),
          node_color = test$data$tax_occ$MeJA_1.0,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

heat_tree(test,
          node_label = test$taxon_names(),
          node_size = test$n_obs(),
          node_color = test$data$tax_occ$MeJA_0.1,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations
          

heat_tree(test,
          node_label = test$taxon_names(),
          node_size = test$n_obs(),
          node_color = test$data$tax_occ$oral_secretion,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

heat_tree(test,
          node_label = test$taxon_names(),
          node_size = test$n_obs(),
          node_color = test$data$tax_occ$control,
          node_size_axis_label = "OTU count",
          node_color_axis_label = "Samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations
          
          
          


```





















# 8.6 OUTDATED - generate importance score based on tag frequency and number of OTUs in data partition
## sum of rarities



```{r}



# dumbest, lazyiest and most repetitive way of assignign scores   
# my eyes hurt and my mind weeps but time is running out and I have to go forward
added_ASV_importance_scores<-lapply(ASV_importance_scores, function(x){
  
  # wit this, we calculate the score for every variable
  numerator<-nrow(x)
  denominator<-sapply(x, sum)
  asv_score<-numerator/denominator
  
 mutant<-x%>% #mutates several columns, one a a time... sapply() or across() should ahve been able to do this!
    mutate(important_in_rf = if_else(condition = important_in_rf>0, true = asv_score[1], false = 0 ))%>%
    mutate(is_keystone_taxa = if_else(condition = is_keystone_taxa>0, true = asv_score[2], false = 0 ))%>%
    mutate(is_module_hub = if_else(condition = is_module_hub>0, true = asv_score[3], false = 0 ))%>%
    mutate(is_module_connector = if_else(condition = is_module_connector>0, true = asv_score[4], false = 0 ))%>%
    mutate(abundant_in_treatment = if_else(condition = abundant_in_treatment>0, true = asv_score[5], false = 0 ))%>%
    mutate(abundant_in_control = if_else(condition = abundant_in_control>0, true = asv_score[6], false = 0 ))%>%
    mutate(abundant_in_2_treatments_simultaneously  = if_else(condition = abundant_in_2_treatments_simultaneously >0, true = asv_score[7], false = 0 ))%>%
    mutate(is_above_expected = if_else(condition = is_above_expected>0, true = asv_score[8], false = 0 ))%>%
    mutate(above_in_2_treatments_absent_control = if_else(condition = above_in_2_treatments_absent_control>0, true = asv_score[9], false = 0 ))%>%
    mutate(above_only_in_control = if_else(condition = above_only_in_control>0, true = asv_score[10], false = 0 ))
    
   output<-mutate(mutant, sumed_scores = rowSums(mutant))
  
return(output)
})

#now let's make a score based on simple sum
tag_sum_score<-lapply(ASV_importance_scores, function(x)
mutate(x, sum_of_importance_tags= rowSums(x)))

view(added_ASV_importance_scores$Brassica_oleraceae.Root)
view(added_ASV_importance_scores$Brassica_oleraceae.Soil)

view(tag_sum_score$Brassica_oleraceae.Root)
view(tag_sum_score$Brassica_oleraceae.Soil)



added_ASV_importance_scores$Brassica_oleraceae.Root$sumed_scores/tag_sum_score$Brassica_oleraceae.Root$sum_of_importance_tags

```

