---
title: "2_beta_diversity"
author: "Pedro Beschoren da Costa"
date: "August 25, 2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

# load libraries and data
```{r}

#Set working directory to project directory 
setwd("./")
getwd() #ok

#Handling data 
library("dplyr")
library("tibble")
library("stringr")  # to wrangle string vectors
library("tidyr")
library("ggrepel")  # to avoid legends overlapping in your plot
library("ggpubr")
library("purrr")  # has map() to select table elements

#Microbiome
library("vegan")  # for several essential statistical tests
library("forcats")
library("metagMisc")  # lets you create lists of split phyloseq objects
library("phyloseq")
library("decontam")
library("metagenomeSeq")
library("Biostrings")
library("mikropml")

#Visuals
library("ggplot2")

#stats
library("agricolae")  # includes some ANOVA post-hoc options
library("minpack.lm")  # lets you do some HSD tests, output is a nice table
library("car")  # for Levene's test

```

Now, get the data from script 1
```{r}

load("./R output/env.1_Loading_and_pre_processing.RData")

#remove all that you dont need
rm(CSS_matrix, decontam_output, MRexp_objt, physeq, physeq_clean, physeq_decontaminated, physeq_norm_pa_neg)

#Check ps objects
normalization_listed$physeq_filtered #original ps, non-normalized, full dataset, same as physeq_filtered
normalization_listed$physeq_filtered_rarefied #rarefied, full dataset
normalization_listed$physeq_filtered_CSS #CSS-normalized, full dataset

```

Let's get the summary of reads in the raw phyloseq
```{r}

# Add new variable 'Sp' as a short name for species
normalization_listed <- lapply(normalization_listed, function(ps){
                        # Add new column 'Sp' with short species names
              sample_data(ps)$Sp <- ifelse(sample_data(ps)$Plant_species == "Arabidopsis_thaliana", "At",
                                          ifelse(sample_data(ps)$Plant_species == "Brassica_oleraceae", "Bo", NA))

                        # Check the first few rows
                        print(head(sample_data(ps)$Sp))
                        
                        #return
                        return(ps)})

#Now add other variable ('Sp_Comp') with the combination of Sp and root compartment (Sample_type)
normalization_listed <- lapply(normalization_listed, function(ps){
                        # Add new column 'Sp' with short species names
                        sample_data(ps)$Sp_Comp <- paste(sample_data(ps)$Sp,
                                              sample_data(ps)$Sample_type, 
                                              sep = "_")

                        # Check the first few rows
                        print(head(sample_data(ps)$Sp_Comp))
                        
                        #return
                        return(ps)})

#Add as well the number of reads and the number of ASVs 
normalization_listed <- lapply(normalization_listed, function(ps){
                        # Add new column 'library_size' 
                        sample_data(ps)$library_size <- sample_sums(ps)
                        
                        #Add new column 'Num_ASVs'
                        sample_data(ps)$Num_ASV <- apply(otu_table(ps), 2, function(x) sum(x > 0))

                        # Check the first few rows
                        print(head(sample_data(ps)))
                        
                        #return
                        return(ps)})

#let's check sample_data
lapply(normalization_listed, function(ps){head(sample_data(ps))})

#split it to get number of ASVs per sub-community
ps_root_soil <- phyloseq_sep_variable(normalization_listed$physeq_filtered, variable = "Sp_Comp")

#get summary
#make a df 
sample_data <- normalization_listed$physeq_filtered %>% 
    sample_data() %>% 
    data.frame()

#let's quickly check how many replicates we have left per Sp and Root compartment (Root=Endosphere, Soil=Rhizosphere)
#and how is the library size amongst them. [part of Supplementary Table S1]
sample_data %>% 
    group_by(Sp, Sample_type)%>%
    dplyr::summarise(Replicates = n(),
              library_size = mean(library_size),
              stdev_libsize =sd(library_size, na.rm = TRUE))

```

## Settings for plots 
```{r}

#Set plots theme
ggplot2::theme_set(theme_bw())

# Set default axis looks
axis_looks <- theme(axis.text.x = element_text(colour = "black", size = 9,
                                               face = "bold", angle=0, hjust=0.5))+ #text in X
  theme(axis.text.y = element_text(colour = "black", size = 9, face = "bold"))+ #text in y
  theme(axis.title=element_text(size=11, face = "bold"))+ #all texts
  theme(axis.title.y = element_text(margin = ggplot2::margin(t = 0, r = 10, b = 0, l = 0)))+
  theme(panel.grid.major = element_blank(), #no grid
        panel.grid.minor = element_blank()) #no grid

#Set colors
color_treatments <- c("#FBF2C4", "#DEA868", "#C7522B", "#9BBAA0") #"Control", "MeJA 0.1mM", "MeJA 1mM", "P. brassicae OS"
color_species <- c("#146627ff", "#1fb695ff") #at & bo, respectively
color_compartment <- c("#e7b083ff", "#905423ff") #endo & rhizo, respectively

```



# 2.0 - basic beta diversity analysis
On this script we will evaluate beta diversity - the differences in the microbial community compositions across samples. we will make ordination plots and multivariate tests


## 2.1 - Beta Diversity plots
Beta diversity plots are the beating heart or microbiome analysis. here you will be able to visually tell if communities differ according to treatment or not. It can be a very long topic but here I only use one option.


```{r}

# Let's make a Non-Metric Multidimensional Scaling (NMDS) of all our samples based on CSS normalization
nmds_rootAndSoil <- phyloseq::ordinate(normalization_listed$physeq_filtered_CSS,
  method = "NMDS", # this method has few assumptions and readly accepts different data structures
  distance = "bray", # bray-curtis distance is suitable for sparse data - such as the zero-inflated microbiome data we have
  try = 200, # number of iterations
  autotransform = TRUE
) # automatically transforms your data, if needed. reduces weight of outliers
# weakties = FALSE prevests tress from colapsing into zero

#First get a short version of sample data df to be used as metadata for NMDS
df_info <- sample_data(normalization_listed$physeq_filtered_CSS) %>% 
               data.frame() %>% 
               dplyr::select(Plant_species, Sample_type, Sp_Comp, MeJA_treatment)%>%
               mutate(sample_name=rownames(.))

#call function
get_NMDS_coordenates <- function(x,y){
  
  #x is a phyloseq
  #should be a string in between "" with the distance (i.e. "bray")
  
  df_nmds <- lapply(y, function(dist){
    ord <- ordinate(x, "NMDS", distance=dist, try=200, autotransform=TRUE)
    nMDS <- plot_ordination(x, ord, color="MeJA_treatment")
    df_NMDS <- nMDS$data
    df_NMDS <- df_NMDS %>% dplyr::select(Plant_species, Sample_type, Sp_Comp,MeJA_treatment,NMDS1, NMDS2)
    df_NMDS$sample_name <- rownames(df_NMDS)
    df_NMDS <- df_NMDS %>% relocate(sample_name)
    return(df_NMDS)
    })

  #ord will be a list 
  return(df_nmds)
}

#get coordinates
df_NMDS <- get_NMDS_coordenates(normalization_listed$physeq_filtered_CSS, "bray")
df_NMDS <- df_NMDS[[1]] #it was a list before idk why

#plot NMDS 
ggplot(df_NMDS, aes(x=NMDS1,y=NMDS2, 
                    fill=MeJA_treatment, #inside
                    shape=Plant_species,
                    color=Sample_type)) + #outline
  geom_point(aes(color=Sample_type, fill=MeJA_treatment, size=4))+ # individual sample values
  scale_shape_manual(values=c(21,24))+
  scale_color_manual(values = c("black", "white"))+ #outline
  scale_fill_manual(values=color_treatments)+ #inside
  ggtitle("NMDS_full")+
  axis_looks

#save plot
mapply(function(x)
  ggsave(
  plot = last_plot(),
  filename =x,
  path = "./Plots/02_beta_diversity",
  scale = 1.5,
  width = 1200,
  height = 850,
  units = "px",
  dpi = 300),
x=c("NMDS_Full.svg","NMDS_Full_16S.png"))

metadata <- as(sample_data(physeq_filtered_CSS), "data.frame")
```


### 2.1.1 - custom NMDS function for automation of split datasets

```{r}

# define custom fucntion to plot a list of NMDS results
NMDS_listing <- function(physeq_list) { # first the name of the new function you are saving, then you say you are going to define a function, and then you set it's arguments - here, a single list of phyloseq objects. the {} indicate where the contents of the custom function start and end.

  # here we perform the NMDS on all elements of the list using phyloseq::ordinate()
  NMDS_list <- lapply(physeq_list, function(x) {
    ordinate(
      physeq = x, # your phyloseq object, each element x in the list
      method = "NMDS", # ordination method to use
      distance = "bray", # distance metric to use
      try = 200, # number of permutations
      autotransform = TRUE
    )
  }) # automatic data transformation

  # mapply will perform one function on two lists. define the lists in the end of the function
  untitled_plot_list <- mapply(function(x, y) { # mapply will run one function on 2 lists
    plot_ordination(
      physeq = x, # your phyloseq object, each element x in the list
      ordination = y, # your phyloseq-generated ordination object, each element y in the list made above
      color = "MeJA_treatment"
    ) + # dot colors in the plot
      theme_classic() + # ggplot option to remove background
      labs(subtitle = paste("Stress:", round(y$stress, digits = 4))) + # this adds the NMDS stress to the plot as subtitle
      theme(plot.title = element_text(size = 10, face = "bold")) + # options for the title
      theme(legend.position = "right")
  }, # position for the legend
  x = physeq_list, # note that you only define x here, after you define your plot function
  y = NMDS_list, # note that you only definee y here, after you define your plot function
  SIMPLIFY = FALSE
  ) # if you simply, all resusts are saved in a vector

  # The plots above miss a title, so you don't really know who is root and who is soil. this code create a list of names to be used as titles in your plot
  tiles_list <- names(untitled_plot_list)

  Plot_list <- mapply(function(z, w) { # use mapply again to put those listed names in the list of plots
    z + ggtitle(w)
  },
  z = untitled_plot_list,
  w = tiles_list,
  SIMPLIFY = FALSE
  )

  return(list(NMDS_list, Plot_list)) # with this you specify the output of your custom function. Note we are saving both the NMDS calculations and the plot as a list, so we don't ahve to re-calculate the NMDS later
}

# let's run our custom function
set.seed(5235)
NMDS_4_slice <- NMDS_listing(ps_list_CSS)
```


## 2.2 - Beta Dispersion

Beta dispersion indicates variance in the multidimensional space. It essentially measures the spread of your data points in the ordination, according your different treatments. As you might expect, statistical tests will have a hard time comparing a treatment with high beta dispersion (wide, sparse datapoint cloud) against a treatment with low beta dispersion (clustered, compact datapoint cloud), just like it is difficult to compare large error bars to small error bars.  You can test for homogeniety of this variance, similarly to a levene test of homogeniety before an anova. 

What if you don't have homogeniety of variances? then your permanova results are not as reliale. This can be difficult to solve. there are a few transformations you could try (log or sqrt of your counts), outliers you could remove (specially if you observed that a particular outlier was specially unhealthy) or just split your permanovas accordingly (if soil samples have higher beta dispersion than root samples, test root and soil in separate permanovas). sometimes however these alternatives do no solve the problem - proceed with your tests as normal but be cautious with your conclusions.

with this chunk we evaluate Beta Dipersion Metrics & plots 
```{r}

# this will test beta dispersions over a list by considering a factor
#### -------- soft-coded, 3 lists of phyloseq objects ---###
beta_disp_plotAndTest <- function(phyloseq_list, group) {
  # phyloseq_list = a list of phyloseq objects
  # group = the variale you want to test the beta dispersion of, in quotes
  beta_disper_list <- lapply(phyloseq_list, function(x) {
    betadisper(phyloseq::distance(t(otu_table(x)), method = "bray"), sample_data(x)[[group]])
  }) # selects only column "group""

  # gets the names of the list
  tiles_list <- names(beta_disper_list)

  # runs anova on beta dispersions
  get_p <- lapply(beta_disper_list, function(x) {
    anova(x, permutations = 999)
  })


  p_dispersion <- map(get_p, 5) # gets the p value of the dispersion test
  p_dispersion <- p_dispersion[!is.na(p_dispersion)] # removes the generated NA


  # runs anova on beta dispersions
  bet_disp_PCOa_plot <- mapply(function(x, y, z) {
    plot(x,
      main = y,
      sub = z,
      xlab = "p value for homogeniety test:",
      ylab = "PCoA"
    )
  },
  x = beta_disper_list,
  y = tiles_list,
  z = p_dispersion,
  SIMPLIFY = FALSE
  )

  # runs anova on beta dispersions
  bet_disp_boxplot <- mapply(function(x, y) {
    boxplot(x, main = y)
  },
  x = beta_disper_list,
  y = tiles_list,
  SIMPLIFY = FALSE
  )


  return(list(bet_disp_PCOa_plot, bet_disp_boxplot))
}

# now that we have a custom function, we can run it across all lists and variables
set.seed(5235)
dip_result3 <- beta_disp_plotAndTest(ps_list_CSS, "MeJA_treatment")
```



## 2.3 - Run PERMANOVA 

A permutation anova will tell if the differences in the microbial community structure are significant or not. they will essentially help you separate the data clouds of your ordination with confidence levels


you will need to run, test and check several different models and data slices to have final insight into the dataset you are evaluating. get used with testing multiple models!

```{r}
# Running the permanova with vegan::adonis2() on a single phyloseq object is very simple
metadata <- as(sample_data(physeq_filtered_CSS), "data.frame")
# let's first define permitation design with permute::how()
perm2 <- how(
  within = Within(type = "free"), # permute observations freely within the blocks. got to ask Fred how to handle grid arrangements!
  blocks = metadata$Block, # define blocks
  nperm = 999
) # n of permutations
set.seed(5235)
# now let's calculate the permanova
three_way_permanova <- adonis2(phyloseq::distance(t(otu_table(physeq_filtered_CSS)), method = "bray") # this is your distance matrix of OTU abundances
~ MeJA_treatment * Plant_species * Sample_type + Block, # this is your model
permutations = perm2, # we jsut defined the permutation settings above, you place them here
data = metadata
) # metadata for the community matrix



#### -------- soft-coded, 3 lists of phyloseq objects with 1 formula ---###

# let's check now if sample type differ per species. note that this function uses Blocks as strata
permanova_with_blocks <- function(phyloseq_list, rhs_model) {
  # phyloseq_list = list of phyloseq objects
  # RHS_model = right hand side model, such as MeJA_treatment*Sample_type + Block
  lapply(phyloseq_list, function(x) {
    lhs_data <- phyloseq::distance(t(otu_table(x)), method = "bray")
    rhs_model_in <- paste(rhs_model)
    form <- as.formula(paste("lhs_data~", paste(rhs_model_in))) # getting the formulat properly evaluated as custom string is tricky
    output <- adonis2(form,
      data = as(sample_data(x), "data.frame"), # changing with as.data.frame is insufficient
      permutations = how(within = Within(type = "free"), blocks = as(sample_data(x), "data.frame")$Block, nperm = 9999)
    ) # how defines the permutations, it is important to adjust it to the experimental design such as a time series
    return(output)
  })
}

# run custom funcion
set.seed(5235)
permanova_with_blocks(ps_list_CSS, "MeJA_treatment + Block")


```
## 2.4 pairwise PERMANOVA

Now that we know the fixed factor effects and interactions, let's make pairwise comparisons.for this we will use EcolUtils::adonis.pair - with lists and p adjust, no blocks

```{r}

# pairwise coparisons over a list fo 4 ps obects
set.seed(5235)
lapply(ps_list_CSS, function(x) {
  adonis.pair(
    dist.mat = phyloseq::distance(otu_table(x), method = "bray"),
    Factor = as.factor(as(phyloseq::sample_data(x), "data.frame")$MeJA_treatment)
  )
})


# pairwise coparisons over afull community
adonis.pair(
dist.mat = phyloseq::distance(otu_table(physeq_filtered_CSS), method = "bray"),
Factor = as.factor(as(phyloseq::sample_data(physeq_filtered_CSS), "data.frame")$MeJA_treatment)
)



```


# 2.5 - Save session
```{r}

save.image("./R output/analysis_session.RData")
```


Beta Diversity analysed! proceed to scrip 3_Alpha_Diversity!

